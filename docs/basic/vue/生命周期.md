---
title: '生命周期'
---

## 生命周期几个阶段

1.创建阶段

`beforeCreate`：

 > 没多大用，只是为了和created成对出现，当然Vue内部对它还是有一定封装

`created`：
 
> 一般在没有路由的情况下，都会在这里去做ajax请求，这时候已经可以获取到数据
> 
> 实例创建完成后。立即执行，能取到数据，页面并没有渲染，不存在dom，所以找不到节点这里就可以对数据进行修改
>
> 如果是同步修改数据，不影响生命周期
>
> 如果是异步修改数据，会在有数据更新的时候，再走到updated

2.装载阶段

`beforeMount`：

> 这里在挂载到页面之前，还可以修改数据
> 
> 虚拟dom已经存在 编译模板已经结束，可以访问数据

`mounted`：
 
> 只有到了这里，才会有真实的dom
>
> 如果修改数据，会触发beforeUpdate updated钩子函数，
> 
> 假如你要在vue里引入第三方的dom库或者包，需要根据dom来实例化，那么，需要在这里来写实例化的代码
> 
> 有时候，为了用户体验，也会在这里做ajax请求

3.更新阶段

`beforeUpdate`：
 
> 在数据更新之前调用，发生在虚拟 DOM 重新渲染和打补丁之前。可以在该钩子中进一步地更改状态，不会触发附加的重渲染过程。

`updated`：
 
> 在由于数据更改导致的虚拟 DOM 重新渲染和打补丁之后调用。
> 
> 调用时，组件 DOM 已经更新，所以可以执行依赖于 DOM 的操作。
> 
> 然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。

4.销毁阶段

`beforeDestory`：

> 在实例销毁之前调用。实例仍然完全可用。
> 
> 在这里会去做一些性能上的优化，比如，清除定时器
> 
`destoryed`：

>  在实例销毁之后调用。调用后，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。

**vm.$destroy()**：完全销毁一个实例。清理它与其它实例的连接，解绑它的全部指令及事件监听器。触发 beforeDestroy 和 destroyed 的钩子。

## keep-alive

> vue可以使用<keep-alive></keep-alive>组件包裹动态组件，包裹之后动态组件的状态会被缓存，
>
> 如果使用动态组件渲染的某个组件使用了created生命周期请求数据，那么下次进入该组件不会再次请求数据，
>
> 因为keep-alive之后所有的动态组件都会被缓存，被缓存之后的组件再次进入就不会执行created，
>
> 如果想要每次进入数据都有更新或者执行某些更新的操作，就应该使用activated生命周期来代替created，
>
> router的生命周期不受keep-alive的影响

* created ->`activated`

* destoryed->`deactivated`

## 可能会问的面试题

### 什么是 vue 生命周期？

Vue 实例从创建到销毁的过程，就是生命周期。从开始创建、初始化数据、编译模板、挂载 Dom→渲染、更新→渲染、销毁等一系列过程，称之为 Vue 的生命周期。

### vue 生命周期的作用是什么？

它的生命周期中有多个事件钩子，让我们在控制整个 Vue 实例的过程时更容易形成好的逻辑。

### vue 生命周期总共有几个阶段？

它可以总共分为 8 个阶段：创建前/后, 载入前/后,更新前/后,销毁前/销毁后。

### 第一次页面加载会触发哪几个钩子？

会触发 下面这几个 beforeCreate, created, beforeMount, mounted 。

### DOM 渲染在 哪个周期中就已经完成？

DOM 渲染在 mounted 中就已经完成了。
